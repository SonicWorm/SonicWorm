import Phaser from 'phaser';
import { multiplayerService, PlayerData, GameState } from '../services/MultiplayerService';
import { web3Service } from '../services/Web3Service';

interface FoodItem {
  x: number;
  y: number;
  color: number;
  size: number;
}

export class GameScene extends Phaser.Scene {
  private player!: PlayerData;
  private otherPlayers: Map<string, PlayerData> = new Map();
  private food: FoodItem[] = [];
  private playerGraphics!: Phaser.GameObjects.Graphics;
  private foodGraphics!: Phaser.GameObjects.Graphics;
  private camera!: Phaser.Cameras.Scene2D.Camera;

  // Game settings - SYNCED WITH SERVER
  private readonly WORLD_SIZE = 2500; // Synced with server (2500x2500)
  private readonly PLAYER_SPEED = 3;
  private readonly BOOST_SPEED = 6;
  private readonly SEGMENT_SIZE = 8;
  private readonly MIN_SEGMENTS = 5;

  // GAME RULES: Server authority - client constants removed
  // Game rules now controlled by server prize pool system

  // Input state
  private isBoostActive = false;

  // Game timing - SENÄ°N KURALLARIN
  private serverGameStartTime: number = 0; // Server'dan gelecek
  
  // SENÄ°N Ä°STEÄÄ°N: Yem sayacÄ± (Slither.io tarzÄ± bÃ¼yÃ¼me iÃ§in)
  
  // Bot sistemi kaldÄ±rÄ±ldÄ± - Sadece multiplayer

  constructor() {
    super({ key: 'GameScene' });
  }

  create() {
    console.log('ğŸ› SonicWorm Game Scene Created');

    // Initialize world bounds
    this.physics.world.setBounds(0, 0, this.WORLD_SIZE, this.WORLD_SIZE);

    // SENÄ°N Ä°STEÄÄ°N: GeliÅŸmiÅŸ arka plan
    this.cameras.main.setBackgroundColor('#0a0f1c');
    
    // SENÄ°N Ä°STEÄÄ°N: Arka plan efektleri
    this.createBackgroundEffects();

    // Setup graphics
    this.playerGraphics = this.add.graphics();
    this.foodGraphics = this.add.graphics();

    // Initialize player
    this.initializePlayer();

    // Generate food
    // REMOVED: generateFood() - Food is now generated by server
    
    // Bot sistemi kaldÄ±rÄ±ldÄ±

    // Setup input
    this.setupInput();

    // Setup camera
    this.setupCamera();

    // Setup UI
    this.setupUI();

    // Setup multiplayer
    this.setupMultiplayer();

    console.log('âœ… SonicWorm ready to play!');
  }


  // SENÄ°N Ä°STEÄÄ°N: Slither.io tarzÄ± arka plan efektleri
  private createBackgroundEffects() {
    // Slither.io tarzÄ± subtle grid pattern
    const gridGraphics = this.add.graphics();
    gridGraphics.lineStyle(0.5, 0x1a1a2e, 0.15); // Daha subtle
    
    for (let i = 0; i < this.WORLD_SIZE; i += 150) { // Daha bÃ¼yÃ¼k aralÄ±k
      gridGraphics.moveTo(i, 0);
      gridGraphics.lineTo(i, this.WORLD_SIZE);
      gridGraphics.moveTo(0, i);
      gridGraphics.lineTo(this.WORLD_SIZE, i);
    }
    gridGraphics.strokePath();
    
    // Slither.io tarzÄ± subtle dots pattern
    const dotsGraphics = this.add.graphics();
    dotsGraphics.fillStyle(0x1a1a2e, 0.1);
    
    for (let i = 0; i < 50; i++) {
      const x = Phaser.Math.Between(0, this.WORLD_SIZE);
      const y = Phaser.Math.Between(0, this.WORLD_SIZE);
      dotsGraphics.fillCircle(x, y, 1);
    }
  }

  // SENÄ°N KURALLARIN: Multiplayer setup
  private setupMultiplayer() {
    // Multiplayer event listeners
    multiplayerService.setOnGameJoined((playerId, roomId, gameState) => {
      console.log(`ğŸ® Joined game: ${roomId} as ${playerId}`);
      this.setPlayerId(playerId); // Use proper ID sync method
      this.updateGameStateFromServer(gameState);
    });

    multiplayerService.setOnPlayerUpdate((playerId, playerData) => {
      if (playerId !== this.player.id) {
        const existingPlayer = this.otherPlayers.get(playerId);
        if (existingPlayer) {
          Object.assign(existingPlayer, playerData);
        }
      }
    });

    multiplayerService.setOnPlayerJoined((player) => {
      if (player.id !== this.player.id) {
        this.otherPlayers.set(player.id, player);
        console.log(`ğŸ‘‹ Player joined: ${player.id}`);
      }
    });

    multiplayerService.setOnPlayerLeft((playerId) => {
      this.otherPlayers.delete(playerId);
      console.log(`ğŸ‘‹ Player left: ${playerId}`);
    });

    multiplayerService.setOnPlayerKilled((killerId, victimId, gameState) => {
      console.log(`âš”ï¸ Player ${killerId} killed ${victimId}`);

      if (victimId === this.player.id) {
        // Ben Ã¶ldÃ¼rÃ¼ldÃ¼m
        this.killPlayer();
      } else if (killerId === this.player.id) {
        // Kill tracking server'dan gelecek
        console.log('âš”ï¸ Kill by me - server will update');
      }

      this.updateGameStateFromServer(gameState);
    });

    multiplayerService.setOnGameState((gameState) => {
      this.updateGameStateFromServer(gameState);
    });

    multiplayerService.setOnError((error) => {
      console.error('Multiplayer error:', error);
    });

    // Multiplayer baÄŸlantÄ±sÄ±nÄ± baÅŸlat
    this.connectToMultiplayer();
  }

  private async connectToMultiplayer() {
    try {
      await multiplayerService.connect();

      // Oyuna katÄ±l
      multiplayerService.joinGame({
        x: this.player.x,
        y: this.player.y,
        angle: this.player.angle,
        segments: this.player.segments,
        kills: this.player.kills,
        isAlive: this.player.isAlive,
        color: this.player.color
      }, web3Service.getCurrentAccount() || undefined, web3Service.getCurrentGameId() || undefined);

    } catch (error) {
      console.error('Failed to connect to multiplayer:', error);
      // Offline modda devam et
    }
  }

  private updateGameStateFromServer(gameState: GameState) {
    // Server'dan game timing bilgisi al
    if (gameState.startTime && !this.serverGameStartTime) {
      this.serverGameStartTime = gameState.startTime;
      console.log('ğŸ• Game start time set from server:', this.serverGameStartTime);
    }
    
    // WALLET ADDRESS MAPPING: Find players by wallet address
    const myWalletAddress = localStorage.getItem('walletAddress');
    this.otherPlayers.clear();
    
    gameState.players.forEach(player => {
      const isMyPlayer = (player as any).walletAddress === myWalletAddress;
      
      if (!isMyPlayer) {
        // Other players
        this.otherPlayers.set(player.id, player);
      } else {
        // My player - sync server data
        const oldKills = this.player.kills;
        
        // Update my player with server data
        this.player.id = player.id; // Server ID sync
        this.player.kills = player.kills;
        this.player.isAlive = player.isAlive;
        (this.player as any).walletAddress = (player as any).walletAddress;
        this.player.segments = player.segments; // Server'dan segment verisini al
        
        // Kill deÄŸiÅŸti mi kontrol et ve UI'ya bildir
        if (oldKills !== player.kills) {
          window.dispatchEvent(new CustomEvent('killUpdated', {
            detail: { kills: player.kills }
          }));
        }
        
        console.log(`ğŸ†” Player synced: ID=${player.id}, Wallet=${myWalletAddress}, Kills=${player.kills}`);
      }
    });

    // Yem durumunu gÃ¼ncelle
    this.food = gameState.food.map(f => ({
      x: f.x,
      y: f.y,
      color: f.color,
      size: f.size
    }));
  }

  // SERVER ID SYNC: Set player ID from server
  public setPlayerId(serverId: string) {
    if (this.player) {
      this.player.id = serverId;
      console.log(`ğŸ†” Player ID set from server: ${serverId}`);
    }
  }

  private initializePlayer() {
    // SENÄ°N Ä°STEÄÄ°N: Rastgele oyuncu rengi seÃ§
    const randomColor = Phaser.Utils.Array.GetRandom(this.PLAYER_COLORS);
    console.log(`ğŸ¨ Oyuncu rengi atandÄ±: #${randomColor.toString(16).padStart(6, '0')}`);
    
    // SENÄ°N Ä°STEÄÄ°N: Rastgele spawn pozisyonu - GÃ¼venli alanda
    const spawnMargin = 150; // Spawn iÃ§in daha bÃ¼yÃ¼k margin
    const spawnX = Phaser.Math.Between(spawnMargin, this.WORLD_SIZE - spawnMargin);
    const spawnY = Phaser.Math.Between(spawnMargin, this.WORLD_SIZE - spawnMargin);

    this.player = {
      id: '', // Will be set by server via setPlayerId()
      x: spawnX,
      y: spawnY,
      angle: 0,
      segments: [],
      kills: 0, // Server'dan gelecek
      isAlive: true,
      color: randomColor, // SENÄ°N Ä°STEÄÄ°N: Rastgele renk
      spawnTime: Date.now(), // Spawn zamanÄ±
      isInvulnerable: true // Ä°lk 20 saniye Ã¶ldÃ¼rÃ¼lemez
    };

    // Initialize segments
    for (let i = 0; i < this.MIN_SEGMENTS; i++) {
      this.player.segments.push({
        x: this.player.x - (i * this.SEGMENT_SIZE),
        y: this.player.y
      });
    }

    // SENÄ°N KURALLARIN: Oyun baÅŸlangÄ±Ã§ zamanÄ±nÄ± kaydet
    // Game start time server'dan gelecek
    
    // SENÄ°N Ä°STEÄÄ°N: Yem sayacÄ±nÄ± sÄ±fÄ±rla
    
    console.log(`ğŸ¯ Player spawned at (${spawnX}, ${spawnY}) - Invulnerable for 10 seconds`);
  }

  // SENÄ°N Ä°STEÄÄ°N: 10-15 farklÄ± oyuncu rengi
  private readonly PLAYER_COLORS = [
    0x00ffcc, // Sonic Cyan (Ana renk)
    0xff6b6b, // Coral Red
    0x4ecdc4, // Teal
    0x45b7d1, // Sky Blue
    0x96ceb4, // Mint Green
    0xfeca57, // Sunny Yellow
    0xff9ff3, // Pink
    0x54a0ff, // Blue
    0x5f27cd, // Purple
    0x00d2d3, // Cyan
    0xff9f43, // Orange
    0x10ac84, // Green
    0xee5a24, // Red Orange
    0x0abde3, // Light Blue
    0xc44569  // Dark Pink
  ];

  // REMOVED: generateFood() - Food generation is now handled by server
  // Server broadcasts food state via GAME_STATE updates

  private setupInput() {

    // SENÄ°N TERCÄ°HLERÄ°N: Cross-platform input sistemi

    // Mouse/touch input for movement (PC + Mobil)
    this.input.on('pointermove', (pointer: Phaser.Input.Pointer) => {
      if (this.player.isAlive) {
        const worldPoint = this.cameras.main.getWorldPoint(pointer.x, pointer.y);
        this.player.angle = Phaser.Math.Angle.Between(
          this.player.x,
          this.player.y,
          worldPoint.x,
          worldPoint.y
        );
      }
    });
    
    // PC: Sol mouse click ile boost
    this.input.on('pointerdown', (pointer: Phaser.Input.Pointer) => {
      if (this.player.isAlive && pointer.leftButtonDown()) {
        this.isBoostActive = true;
      }
      // Touch cihazlarda boost aktif et
      if (this.player.isAlive && pointer.isDown && this.input.activePointer.wasTouch) {
        this.isBoostActive = true;
      }
    });
    this.input.on('pointerup', (pointer: Phaser.Input.Pointer) => {
      // Sol mouse click bÄ±rakÄ±lÄ±nca boost kapansÄ±n
      if (!pointer.leftButtonDown()) {
        this.isBoostActive = false;
      }
      // Touch boost'u kapat
      if (this.input.activePointer.wasTouch) {
        this.isBoostActive = false;
      }
    });

    // SENÄ°N TERCÄ°HLERÄ°N: Boost kontrolleri
    // PC: Space tuÅŸu - Daha gÃ¼venilir sistem
    this.input.keyboard!.on('keydown-SPACE', () => {
      console.log('ğŸš€ Space tuÅŸu basÄ±ldÄ± - Boost aktif!');
      if (this.player.isAlive) {
        this.isBoostActive = true;
      }
    });

    this.input.keyboard!.on('keyup-SPACE', () => {
      console.log('ğŸ›‘ Space tuÅŸu bÄ±rakÄ±ldÄ± - Boost deaktif!');
      this.isBoostActive = false;
    });
    
    // Alternatif Space tuÅŸu kontrolÃ¼
    this.input.keyboard!.on('keydown', (event: KeyboardEvent) => {
      if (event.code === 'Space' && this.player.isAlive) {
        console.log('ğŸš€ Space tuÅŸu (alternatif) - Boost aktif!');
        this.isBoostActive = true;
      }
    });
    
    this.input.keyboard!.on('keyup', (event: KeyboardEvent) => {
      if (event.code === 'Space') {
        console.log('ğŸ›‘ Space tuÅŸu (alternatif) - Boost deaktif!');
        this.isBoostActive = false;
      }
    });

    // Mobil: Ekrana tap (touch)
    this.input.on('pointerdown', (pointer: Phaser.Input.Pointer) => {
      if (this.player.isAlive && pointer.isDown) {
        // Touch cihazlarda boost aktif et
        if (this.input.activePointer.wasTouch) {
          this.isBoostActive = true;
        }
      }
    });

    this.input.on('pointerup', () => {
      // Touch boost'u kapat
      if (this.input.activePointer.wasTouch) {
        this.isBoostActive = false;
      }
    });

    // SENÄ°N TERCÄ°HLERÄ°N: Landscape mode zorla
    if (screen && screen.orientation) {
      try {
        if (screen.orientation && 'lock' in screen.orientation) {
          (screen.orientation as any).lock('landscape');
        }
      } catch (e) {
        console.log('Screen orientation lock not supported');
      }
    }
  }

  private setupCamera() {
    this.camera = this.cameras.main;
    this.camera.setBounds(0, 0, this.WORLD_SIZE, this.WORLD_SIZE);
    this.camera.setZoom(1);
  }

  private setupUI() {
    // UI kaldÄ±rÄ±ldÄ± - GameComponent.tsx'deki UI kullanÄ±lacak
    // Bu sayede duplicate UI sorunu Ã§Ã¶zÃ¼ldÃ¼
  }

  update() {
    if (!this.player.isAlive) return;

    this.updatePlayer();
    // CLIENT-SIDE ONLY: Rendering and UI
    this.updateCamera();
    this.checkBoundaries();
    this.updateInvulnerability(); // Client-side invulnerability display
    this.render();
    // REMOVED: checkFoodCollisions() - now on server
    // REMOVED: updateGameTimer() - now on server
    // Bot death effect kaldÄ±rÄ±ldÄ±
  }


  private updatePlayer() {
    // Calculate speed (boost or normal)
    const speed = this.isBoostActive ? this.BOOST_SPEED : this.PLAYER_SPEED;

    // Debug: Boost durumunu kontrol et (performans iÃ§in azaltÄ±ldÄ±)
    if (this.isBoostActive && Math.random() < 0.1) { // Sadece %10 ÅŸansla log
      console.log('âš¡ Boost aktif - HÄ±z:', speed, 'Segments:', this.player.segments.length, 'Uzama efekti aktif!');
    }
    
    // SENÄ°N Ä°STEÄÄ°N: Boost efekti - Segment kaybetme (KALDIRILDI)
    // Boost sÄ±rasÄ±nda segment kaybetme kaldÄ±rÄ±ldÄ± - segmentler kalÄ±cÄ± olsun
    // if (this.isBoostActive && this.player.segments.length > this.MIN_SEGMENTS) {
    //   if (Math.random() < 0.05) {
    //     this.player.segments.pop();
    //     console.log('âš¡ Boost: Segment lost! Remaining:', this.player.segments.length);
    //   }
    // }

    // Move player head
    this.player.x += Math.cos(this.player.angle) * speed;
    this.player.y += Math.sin(this.player.angle) * speed;

    // Update segments (follow the head) - SENÄ°N Ä°STEÄÄ°N: Boost ile uzama efekti
    if (this.player.segments.length > 0) {
      // SENÄ°N Ä°STEÄÄ°N: Segment pozisyonlarÄ±nÄ± gÃ¼ncelle
      // Ä°lk segmenti (kafa) gÃ¼ncelle
      this.player.segments[0].x = this.player.x;
      this.player.segments[0].y = this.player.y;
      
      // SENÄ°N Ä°STEÄÄ°N: Boost ile segment aralÄ±ÄŸÄ±nÄ± artÄ±r
      const baseDistance = this.SEGMENT_SIZE;
      const boostMultiplier = this.isBoostActive ? 1.8 : 1.0; // Boost sÄ±rasÄ±nda %80 daha uzak
      const targetDistance = baseDistance * boostMultiplier;

      // Smooth segment following - Boost efekti ile
      for (let i = 1; i < this.player.segments.length; i++) {
        const prev = this.player.segments[i - 1];
        const curr = this.player.segments[i];

        // SENÄ°N Ä°STEÄÄ°N: Boost ile uzama efekti
        const dx = prev.x - curr.x;
        const dy = prev.y - curr.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > targetDistance) {
          const ratio = targetDistance / distance;
          curr.x = prev.x - dx * ratio;
          curr.y = prev.y - dy * ratio;
        }
      }
    }

    // SENÄ°N KURALLARIN: Multiplayer sync
    this.syncPlayerToServer();
  }

  // SENÄ°N KURALLARIN: Player durumunu server'a gÃ¶nder
  private syncPlayerToServer() {
    if (multiplayerService.isConnected() && this.player.isAlive) {
      // Throttle updates (20 FPS) - Daha sÄ±k gÃ¼ncelleme
      if (!this.lastSyncTime || Date.now() - this.lastSyncTime > 50) {
        multiplayerService.updatePlayer({
          x: Math.round(this.player.x), // KoordinatlarÄ± yuvarla
          y: Math.round(this.player.y),
          angle: this.player.angle,
          segments: this.player.segments.map(seg => ({
            x: Math.round(seg.x),
            y: Math.round(seg.y)
          })),
          kills: this.player.kills,
          isAlive: this.player.isAlive,
          color: this.player.color
        });
        this.lastSyncTime = Date.now();
      }
    }
  }

  private lastSyncTime: number = 0;

  private updateCamera() {
    // Follow player with smooth camera
    this.camera.centerOn(this.player.x, this.player.y);
    
    // DÄ°NAMÄ°K ZOOM SÄ°STEMÄ° - Segment sayÄ±sÄ±na gÃ¶re zoom deÄŸiÅŸir
    const segmentCount = this.player.segments.length;
    let minZoom, maxZoom;
    
    if (segmentCount <= 10) {
      // KÃ¼Ã§Ã¼k YÄ±lan (0-10 segment): Daha yakÄ±n gÃ¶rÃ¼ÅŸ
      minZoom = 1.0;
      maxZoom = 1.2;
    } else if (segmentCount <= 20) {
      // Orta YÄ±lan (11-20 segment): Orta gÃ¶rÃ¼ÅŸ 
      minZoom = 0.8;
      maxZoom = 1.0;
    } else {
      // BÃ¼yÃ¼k YÄ±lan (20+ segment): En geniÅŸ gÃ¶rÃ¼ÅŸ
      minZoom = 0.6;
      maxZoom = 0.8;
    }
    
    // Her kategori iÃ§inde smooth geÃ§iÅŸ
    let categoryProgress;
    if (segmentCount <= 10) {
      categoryProgress = segmentCount / 10; // 0-10 arasÄ± normalize et
    } else if (segmentCount <= 20) {
      categoryProgress = (segmentCount - 10) / 10; // 11-20 arasÄ± normalize et  
    } else {
      categoryProgress = Math.min((segmentCount - 20) / 30, 1); // 20+ normalize et (max 50'ye kadar)
    }
    
    // Smooth zoom geÃ§iÅŸi - bÃ¼yÃ¼dÃ¼kÃ§e zoom out
    const targetZoom = maxZoom - (categoryProgress * (maxZoom - minZoom));
    
    // Debug: Zoom deÄŸiÅŸimini logla (performans iÃ§in sadece deÄŸiÅŸtiÄŸinde)
    if (this.lastZoom !== targetZoom) {
      console.log(`ğŸ” Zoom Update: Segments=${segmentCount}, Category=${segmentCount <= 10 ? 'Small' : segmentCount <= 20 ? 'Medium' : 'Large'}, Zoom=${targetZoom.toFixed(2)}`);
      this.lastZoom = targetZoom;
    }
    
    this.camera.setZoom(targetZoom);
  }
  
  private lastZoom: number = 0; // Debug iÃ§in

  // REMOVED: checkFoodCollisions() - Food collision is now handled on server
  // Server broadcasts food changes and player growth via GAME_STATE_UPDATE

  // SENÄ°N Ä°STEÄÄ°N: Daha gÃ¼zel yem renkleri

  // SERVER AUTHORITY: Collision detection server'da yapÄ±lÄ±yor
  // Client sadece server'dan gelen death event'ini iÅŸler


  // SENÄ°N KURALLARIN: Ã–lÃ¼m efekti


  private checkBoundaries() {
    // Karakterin oyun alanÄ± dÄ±ÅŸÄ±na Ã§Ä±kmasÄ±nÄ± engelle
    const margin = 100; // âœ… Kenarlardan 100 pixel mesafe bÄ±rak - Daha gÃ¼venli alan

    // X ekseni sÄ±nÄ±rlarÄ±
    if (this.player.x < margin) {
      this.player.x = margin;
    }
    if (this.player.x > this.WORLD_SIZE - margin) {
      this.player.x = this.WORLD_SIZE - margin;
    }
    
    // Y ekseni sÄ±nÄ±rlarÄ±
    if (this.player.y < margin) {
      this.player.y = margin;
    }
    if (this.player.y > this.WORLD_SIZE - margin) {
      this.player.y = this.WORLD_SIZE - margin;
    }
  }

  private render() {
    // Clear graphics
    this.playerGraphics.clear();
    this.foodGraphics.clear();

    // SENÄ°N Ä°STEÄÄ°N: Performans iÃ§in optimize edilmiÅŸ yem render
    this.food.forEach(foodItem => {
      // BasitleÅŸtirilmiÅŸ yem render (performans iÃ§in)
      this.foodGraphics.fillStyle(foodItem.color, 0.95);
      this.foodGraphics.fillCircle(foodItem.x, foodItem.y, foodItem.size);
      
      // Sadece outline (performans iÃ§in)
      this.foodGraphics.lineStyle(1, 0x000000, 0.3);
      this.foodGraphics.strokeCircle(foodItem.x, foodItem.y, foodItem.size);
    });

    // Render player
    this.renderPlayer(this.player);

    // Render other players (for multiplayer later)
    this.otherPlayers.forEach(player => {
      this.renderPlayer(player);
    });
  }

  private renderPlayer(player: PlayerData) {
    if (!player.isAlive) return;

    // SENÄ°N Ä°STEÄÄ°N: Slither.io tarzÄ± profesyonel gÃ¶rsel
    const isInvulnerable = player.isInvulnerable || false;
    const isBoosted = this.isBoostActive && player.id === this.player.id; // Boost kontrolÃ¼
    const invulnerabilityAlpha = isInvulnerable ? 0.7 : 0.95; // Daha opak
    
    // SENÄ°N Ä°STEÄÄ°N: Boost sÄ±rasÄ±nda kendi renginde kal
    const playerColor = player.color; // Her zaman kendi renginde
    const glowIntensity = isInvulnerable ? 0.6 : (isBoosted ? 0.4 : 0.2); // Boost sÄ±rasÄ±nda daha parlak
    
    // Render segments (body) with Slither.io style
    for (let i = player.segments.length - 1; i >= 0; i--) {
      const segment = player.segments[i];
      const size = i === 0 ? this.SEGMENT_SIZE + 2 : this.SEGMENT_SIZE; // Slither.io tarzÄ± kafa
      
      // SENÄ°N Ä°STEÄÄ°N: Slither.io tarzÄ± glow (daha subtle)
      this.playerGraphics.fillStyle(0xffffff, glowIntensity * 0.2);
      this.playerGraphics.fillCircle(segment.x, segment.y, size + 2);

      // SENÄ°N Ä°STEÄÄ°N: Slither.io tarzÄ± gradient body
      this.playerGraphics.fillStyle(playerColor, invulnerabilityAlpha);
      this.playerGraphics.fillCircle(segment.x, segment.y, size);

      // SENÄ°N Ä°STEÄÄ°N: Slither.io tarzÄ± outline
      if (isInvulnerable) {
        // Invulnerable oyuncular iÃ§in Slither.io tarzÄ± glow
        this.playerGraphics.lineStyle(3, 0x00ffcc, 0.8);
        this.playerGraphics.strokeCircle(segment.x, segment.y, size + 2);
        
        // Subtle extra glow
        this.playerGraphics.lineStyle(1, 0xffffff, 0.4);
        this.playerGraphics.strokeCircle(segment.x, segment.y, size + 4);
      } else if (isBoosted) {
        // Boost sÄ±rasÄ±nda daha belirgin outline
        this.playerGraphics.lineStyle(3, playerColor, 0.8); // Kendi rengiyle kalÄ±n outline
        this.playerGraphics.strokeCircle(segment.x, segment.y, size + 2);
        
        // Boost glow efekti
        this.playerGraphics.lineStyle(2, playerColor, 0.6); // Kendi rengiyle glow
        this.playerGraphics.strokeCircle(segment.x, segment.y, size + 4);
      } else {
        // Slither.io tarzÄ± normal outline
        this.playerGraphics.lineStyle(2, 0x000000, 0.6);
      this.playerGraphics.strokeCircle(segment.x, segment.y, size);
        
        // Slither.io tarzÄ± highlight
        this.playerGraphics.lineStyle(1, 0xffffff, 0.3);
        this.playerGraphics.strokeCircle(segment.x, segment.y, size - 1);
      }
    }

    // Render head with eyes
    if (player.segments.length > 0) {
      const head = player.segments[0];

      // Head
      this.playerGraphics.fillStyle(player.color);
      this.playerGraphics.fillCircle(head.x, head.y, this.SEGMENT_SIZE + 2);

      // Eyes
      const eyeOffset = 6;
      const eyeAngle1 = player.angle - 0.5;
      const eyeAngle2 = player.angle + 0.5;

      this.playerGraphics.fillStyle(0xffffff);
      this.playerGraphics.fillCircle(
        head.x + Math.cos(eyeAngle1) * eyeOffset,
        head.y + Math.sin(eyeAngle1) * eyeOffset,
        2
      );
      this.playerGraphics.fillCircle(
        head.x + Math.cos(eyeAngle2) * eyeOffset,
        head.y + Math.sin(eyeAngle2) * eyeOffset,
        2
      );

      // Pupils
      this.playerGraphics.fillStyle(0x000000);
      this.playerGraphics.fillCircle(
        head.x + Math.cos(eyeAngle1) * eyeOffset,
        head.y + Math.sin(eyeAngle1) * eyeOffset,
        1
      );
      this.playerGraphics.fillCircle(
        head.x + Math.cos(eyeAngle2) * eyeOffset,
        head.y + Math.sin(eyeAngle2) * eyeOffset,
        1
      );
    }
  }


  // REMOVED: updateGameTimer() - Timer is now managed by server
  // Server broadcasts timer updates via TIMER_UPDATE events

  // SENÄ°N Ä°STEÄÄ°N: Invulnerability kontrolÃ¼
  private updateInvulnerability() {
    const currentTime = Date.now();
    const spawnElapsed = currentTime - this.player.spawnTime;
    const invulnerabilityDuration = 10000; // 10 saniye (milliseconds)
    
    // 10 saniye geÃ§ti mi kontrol et
    if (spawnElapsed >= invulnerabilityDuration && this.player.isInvulnerable) {
      this.player.isInvulnerable = false;
      console.log('ğŸ›¡ï¸ Invulnerability ended - Player can now be killed');
    }
    
    // Debug: Invulnerability durumunu gÃ¶ster
    if (this.player.isInvulnerable) {
      const remainingTime = Math.ceil((invulnerabilityDuration - spawnElapsed) / 1000);
      console.log(`ğŸ›¡ï¸ Invulnerable for ${remainingTime} more seconds`);
    }
  }


  // SERVER AUTHORITY: Oyun bitme server'dan geliyor
  private endGame() {
    this.player.isAlive = false;
    const elapsedTime = this.serverGameStartTime ? Date.now() - this.serverGameStartTime : 0;

    console.log('ğŸ Game ended - Time:', elapsedTime);

    // Emit death event (will be used for blockchain integration)
    this.events.emit('playerDied', {
      kills: this.player.kills, // Server'dan gelen son deÄŸer
      survivalTime: elapsedTime
    });
  }

  // Public methods for external access - SENÄ°N KURALLARIN
  public getPlayerKills(): number {
    return this.player.kills; // Server authority
  }

  public getGameTime(): number {
    return this.serverGameStartTime ? Date.now() - this.serverGameStartTime : 0;
  }

  public isPlayerAlive(): boolean {
    return this.player.isAlive;
  }

  public killPlayer() {
    this.player.isAlive = false;
    this.endGame();
    
    // âœ… Ã–LEN OYUNCU Ä°Ã‡Ä°N BLOCKCHAIN RESET Ã‡AÄIR
    const walletAddress = localStorage.getItem('walletAddress');
    if (walletAddress) {
      import('../services/Web3Service').then(({ web3Service }) => {
        web3Service.forceEndActiveGame(); // TÃ¼m reset fonksiyonlarÄ±nÄ± dene
      }).catch(error => {
        console.error('âŒ Failed to reset killed player:', error);
      });
    }
  }

  public resetPlayer() {
    this.initializePlayer();
    // REMOVED: generateFood() - Food is now generated by server
  }
}