import Phaser from 'phaser';
import { multiplayerService, PlayerData, GameState } from '../services/MultiplayerService';
import { web3Service } from '../services/Web3Service';

interface FoodItem {
  x: number;
  y: number;
  color: number;
  size: number;
}

export class GameScene extends Phaser.Scene {
  private player!: PlayerData;
  private otherPlayers: Map<string, PlayerData> = new Map();
  private food: FoodItem[] = [];
  // private cursors!: Phaser.Types.Input.Keyboard.CursorKeys; // kept for future use
  private playerGraphics!: Phaser.GameObjects.Graphics;
  private foodGraphics!: Phaser.GameObjects.Graphics;
  private camera!: Phaser.Cameras.Scene2D.Camera;

  // Game settings - SYNCED WITH SERVER
  private readonly WORLD_SIZE = 2500; // Synced with server (2500x2500)
  private readonly PLAYER_SPEED = 3;
  private readonly BOOST_SPEED = 6;
  private readonly SEGMENT_SIZE = 8;
  // private readonly FOOD_COUNT = 375; // not used on client anymore
  private readonly MIN_SEGMENTS = 5;

  // GAME RULES: Server authority - client constants removed
  // Game rules now controlled by server prize pool system

  // Input state
  // private mousePointer!: Phaser.Input.Pointer;
  private isBoostActive = false;

  // Game timing - SENİN KURALLARIN
  private serverGameStartTime: number = 0; // Server'dan gelecek
  // private gameTimer: Phaser.Time.TimerEvent | null = null;
  
  // SENİN İSTEĞİN: Yem sayacı (Slither.io tarzı büyüme için)
  // private foodEatenCount: number = 0;
  private currentGameId: number | null = null;
  
  // Bot sistemi kaldırıldı - Sadece multiplayer

  constructor() {
    super({ key: 'GameScene' });
  }

  create() {
    console.log('🐛 SonicWorm Game Scene Created');

    // Initialize world bounds
    this.physics.world.setBounds(0, 0, this.WORLD_SIZE, this.WORLD_SIZE);

    // SENİN İSTEĞİN: Gelişmiş arka plan
    this.cameras.main.setBackgroundColor('#0a0f1c');
    
    // SENİN İSTEĞİN: Arka plan efektleri
    this.createBackgroundEffects();

    // Setup graphics
    this.playerGraphics = this.add.graphics();
    this.foodGraphics = this.add.graphics();

    // Initialize player
    this.initializePlayer();

    // Generate food
    // REMOVED: generateFood() - Food is now generated by server
    
    // Bot sistemi kaldırıldı

    // Setup input
    this.setupInput();

    // Setup camera
    this.setupCamera();

    // Setup UI
    this.setupUI();

    // Setup multiplayer
    this.setupMultiplayer();

    console.log('✅ SonicWorm ready to play!');
  }


  // SENİN İSTEĞİN: Slither.io tarzı arka plan efektleri
  private createBackgroundEffects() {
    // Slither.io tarzı subtle grid pattern
    const gridGraphics = this.add.graphics();
    gridGraphics.lineStyle(0.5, 0x1a1a2e, 0.15); // Daha subtle
    
    for (let i = 0; i < this.WORLD_SIZE; i += 150) { // Daha büyük aralık
      gridGraphics.moveTo(i, 0);
      gridGraphics.lineTo(i, this.WORLD_SIZE);
      gridGraphics.moveTo(0, i);
      gridGraphics.lineTo(this.WORLD_SIZE, i);
    }
    gridGraphics.strokePath();
    
    // Slither.io tarzı subtle dots pattern
    const dotsGraphics = this.add.graphics();
    dotsGraphics.fillStyle(0x1a1a2e, 0.1);
    
    for (let i = 0; i < 50; i++) {
      const x = Phaser.Math.Between(0, this.WORLD_SIZE);
      const y = Phaser.Math.Between(0, this.WORLD_SIZE);
      dotsGraphics.fillCircle(x, y, 1);
    }
  }

  // SENİN KURALLARIN: Multiplayer setup
  private setupMultiplayer() {
    console.log('🔌 Setting up multiplayer for GameScene');
    
    // Multiplayer event listeners
    multiplayerService.setOnGameJoined((playerId, roomId, gameState) => {
      console.log(`🎮 Joined game: ${roomId} as ${playerId}`);
      this.setPlayerId(playerId); // Use proper ID sync method
      this.updateGameStateFromServer(gameState);
    });

    multiplayerService.setOnPlayerUpdate((playerId, playerData) => {
      if (playerId !== this.player.id) {
        const existingPlayer = this.otherPlayers.get(playerId);
        if (existingPlayer) {
          Object.assign(existingPlayer, playerData);
        }
      }
    });

    multiplayerService.setOnPlayerJoined((player) => {
      if (player.id !== this.player.id) {
        this.otherPlayers.set(player.id, player);
        console.log(`👋 Player joined: ${player.id}`);
      }
    });

    multiplayerService.setOnPlayerLeft((playerId) => {
      this.otherPlayers.delete(playerId);
      console.log(`👋 Player left: ${playerId}`);
    });

    multiplayerService.setOnPlayerKilled((killerId, victimId, gameState) => {
      console.log(`⚔️ Player ${killerId} killed ${victimId}`);

      if (victimId === this.player.id) {
        // Ben öldürüldüm
        this.killPlayer();
      } else if (killerId === this.player.id) {
        // Kill tracking server'dan gelecek
        console.log('⚔️ Kill by me - server will update');
      }

      this.updateGameStateFromServer(gameState);
    });

    multiplayerService.setOnGameState((gameState) => {
      this.updateGameStateFromServer(gameState);
    });

    multiplayerService.setOnError((error) => {
      console.error('Multiplayer error:', error);
    });

    // 🎯 OPTIMIZED: Listen for food creation events
    window.addEventListener('foodCreated', this.handleFoodCreated as unknown as EventListener);

    // Multiplayer bağlantısını başlat
    this.connectToMultiplayer();
  }

  private async connectToMultiplayer() {
    try {
      await multiplayerService.connect();

      // Oyuna katıl
      multiplayerService.joinGame({
        x: this.player.x,
        y: this.player.y,
        angle: this.player.angle,
        segments: this.player.segments,
        kills: this.player.kills,
        isAlive: this.player.isAlive,
        color: this.player.color
    }, web3Service.getCurrentAccount() || undefined, web3Service.getCurrentGameId() || undefined);

    } catch (error) {
      console.error('Failed to connect to multiplayer:', error);
      // Offline modda devam et
    }
  }

  // 🎯 EXACT LOCAL SYSTEM: Copy from working local GameScene.ts
  private updateGameStateFromServer(gameState: GameState) {
    // Server'dan game timing bilgisi al
    if (gameState.startTime && !this.serverGameStartTime) {
      this.serverGameStartTime = gameState.startTime;
      console.log('🕐 Game start time set from server:', this.serverGameStartTime);
    }
    
    // 🎯 REFERENCE-BEHAVIOR: Clear and rebuild from snapshot using wallet matching
    const myWalletAddress = localStorage.getItem('walletAddress');
    this.otherPlayers.clear();
    
    gameState.players.forEach(player => {
      const isMyPlayer = ((player as any).walletAddress || '') === (myWalletAddress || '');
      
      if (!isMyPlayer) {
        const withSegments = {
          ...player,
          segments: player.segments || this.generateSegmentsFromCount({
            x: player.x,
            y: player.y,
            segmentCount: (player as any).segmentCount || 5
          })
        } as any;
        this.otherPlayers.set(player.id, withSegments);
      } else {
        // My player - sync server data
        const oldKills = this.player.kills;
        
        // Update my player with server data
        this.player.id = player.id; // Server ID sync
        this.player.kills = player.kills;
        this.player.isAlive = player.isAlive;
        (this.player as any).walletAddress = (player as any).walletAddress;
        
        // Kill değişti mi kontrol et ve UI'ya bildir
        if (oldKills !== player.kills) {
          window.dispatchEvent(new CustomEvent('killUpdated', {
            detail: { kills: player.kills }
          }));
        }
      }
    });

    // Yem durumunu güncelle
    this.food = gameState.food?.map(f => ({ x: f.x, y: f.y, color: f.color, size: f.size })) || this.food;
  }
  
  // 🎯 OPTIMIZED: Generate segments from count for other players
  private generateSegmentsFromCount(player: any): any[] {
    if (!player.segmentCount) return [];
    
    const segments = [];
    for (let i = 0; i < player.segmentCount; i++) {
      segments.push({
        x: player.x - (i * this.SEGMENT_SIZE),
        y: player.y
      });
    }
    return segments;
  }

  // 🎯 OPTIMIZED: Interpolate other players for smooth movement
  private interpolateOtherPlayers(dt: number) {
    // ms provided by Phaser update(delta)
    // Exponential smoothing mapped to actual frame time
    const baseSmoothing = 0.15; // smoothing per ~16.67ms frame
    const lerpFactor = 1 - Math.pow(1 - baseSmoothing, dt / 16.67);
    const snapDistance = 100; // if far away, snap to target to avoid rubber-banding
    const epsilon = 0.5; // ignore micro jitters

    this.otherPlayers.forEach(player => {
      if (player.targetX !== undefined && player.targetY !== undefined) {
        const dx = player.targetX - player.x;
        const dy = player.targetY - player.y;
        const distSq = dx * dx + dy * dy;

        if (distSq >= snapDistance * snapDistance) {
          // Too far: snap directly
          player.x = player.targetX;
          player.y = player.targetY;
        } else if (Math.abs(dx) > epsilon || Math.abs(dy) > epsilon) {
          // Smoothly approach target
          player.x = player.x + dx * lerpFactor;
          player.y = player.y + dy * lerpFactor;
        }
      }
    });
  }

  // SERVER ID SYNC: Set player ID from server
  public setPlayerId(serverId: string) {
    if (this.player) {
      this.player.id = serverId;
      console.log(`🆔 Player ID set from server: ${serverId}`);
    }
  }

  private initializePlayer() {
    // SENİN İSTEĞİN: Rastgele oyuncu rengi seç
    const randomColor = Phaser.Utils.Array.GetRandom(this.PLAYER_COLORS);
    console.log(`🎨 Oyuncu rengi atandı: #${randomColor.toString(16).padStart(6, '0')}`);
    
    // SENİN İSTEĞİN: Rastgele spawn pozisyonu - Güvenli alanda
    const spawnMargin = 150; // Spawn için daha büyük margin
    const spawnX = Phaser.Math.Between(spawnMargin, this.WORLD_SIZE - spawnMargin);
    const spawnY = Phaser.Math.Between(spawnMargin, this.WORLD_SIZE - spawnMargin);

    this.player = {
      id: '', // Will be set by server via setPlayerId()
      x: spawnX,
      y: spawnY,
      angle: 0,
      segments: [],
      kills: 0, // Server'dan gelecek
      isAlive: true,
      color: randomColor, // SENİN İSTEĞİN: Rastgele renk
      spawnTime: Date.now(), // Spawn zamanı
      isInvulnerable: true // İlk 20 saniye öldürülemez
    };

    // Initialize segments
    for (let i = 0; i < this.MIN_SEGMENTS; i++) {
      this.player.segments.push({
        x: this.player.x - (i * this.SEGMENT_SIZE),
        y: this.player.y
      });
    }

    // SENİN KURALLARIN: Oyun başlangıç zamanını kaydet
    // Game start time server'dan gelecek
    
    // SENİN İSTEĞİN: Yem sayacını sıfırla
    // this.foodEatenCount = 0;
    
    console.log(`🎯 Player spawned at (${spawnX}, ${spawnY}) - Invulnerable for 10 seconds`);
  }

  // SENİN İSTEĞİN: 10-15 farklı oyuncu rengi
  private readonly PLAYER_COLORS = [
    0x00ffcc, // Sonic Cyan (Ana renk)
    0xff6b6b, // Coral Red
    0x4ecdc4, // Teal
    0x45b7d1, // Sky Blue
    0x96ceb4, // Mint Green
    0xfeca57, // Sunny Yellow
    0xff9ff3, // Pink
    0x54a0ff, // Blue
    0x5f27cd, // Purple
    0x00d2d3, // Cyan
    0xff9f43, // Orange
    0x10ac84, // Green
    0xee5a24, // Red Orange
    0x0abde3, // Light Blue
    0xc44569  // Dark Pink
  ];

  // REMOVED: generateFood() - Food generation is now handled by server
  // Server broadcasts food state via GAME_STATE updates

  private setupInput() {
    // Cursors not used; keep input via pointer events only

    // SENİN TERCİHLERİN: Cross-platform input sistemi

    // Mouse/touch input for movement (PC + Mobil)
    this.input.on('pointermove', (pointer: Phaser.Input.Pointer) => {
      if (this.player.isAlive) {
        const worldPoint = this.cameras.main.getWorldPoint(pointer.x, pointer.y);
        this.player.angle = Phaser.Math.Angle.Between(
          this.player.x,
          this.player.y,
          worldPoint.x,
          worldPoint.y
        );
      }
    });
    
    // PC: Sol mouse click ile boost
    this.input.on('pointerdown', (pointer: Phaser.Input.Pointer) => {
      if (this.player.isAlive && pointer.leftButtonDown()) {
        this.isBoostActive = true;
      }
      // Touch cihazlarda boost aktif et
      if (this.player.isAlive && pointer.isDown && this.input.activePointer.wasTouch) {
        this.isBoostActive = true;
      }
    });
    this.input.on('pointerup', (pointer: Phaser.Input.Pointer) => {
      // Sol mouse click bırakılınca boost kapansın
      if (!pointer.leftButtonDown()) {
        this.isBoostActive = false;
      }
      // Touch boost'u kapat
      if (this.input.activePointer.wasTouch) {
        this.isBoostActive = false;
      }
    });

    // SENİN TERCİHLERİN: Boost kontrolleri
    // PC: Space tuşu - Daha güvenilir sistem
    this.input.keyboard!.on('keydown-SPACE', () => {
      console.log('🚀 Space tuşu basıldı - Boost aktif!');
      if (this.player.isAlive) {
        this.isBoostActive = true;
      }
    });

    this.input.keyboard!.on('keyup-SPACE', () => {
      console.log('🛑 Space tuşu bırakıldı - Boost deaktif!');
      this.isBoostActive = false;
    });
    
    // Alternatif Space tuşu kontrolü
    this.input.keyboard!.on('keydown', (event: KeyboardEvent) => {
      if (event.code === 'Space' && this.player.isAlive) {
        console.log('🚀 Space tuşu (alternatif) - Boost aktif!');
        this.isBoostActive = true;
      }
    });
    
    this.input.keyboard!.on('keyup', (event: KeyboardEvent) => {
      if (event.code === 'Space') {
        console.log('🛑 Space tuşu (alternatif) - Boost deaktif!');
        this.isBoostActive = false;
      }
    });

    // Mobil: Ekrana tap (touch)
    this.input.on('pointerdown', (pointer: Phaser.Input.Pointer) => {
      if (this.player.isAlive && pointer.isDown) {
        // Touch cihazlarda boost aktif et
        if (this.input.activePointer.wasTouch) {
          this.isBoostActive = true;
        }
      }
    });

    this.input.on('pointerup', () => {
      // Touch boost'u kapat
      if (this.input.activePointer.wasTouch) {
        this.isBoostActive = false;
      }
    });

    // SENİN TERCİHLERİN: Landscape mode zorla
    if (screen && screen.orientation) {
      try {
        if ('lock' in screen.orientation) {
          // @ts-ignore
        screen.orientation.lock('landscape');
        }
      } catch (e) {
        console.log('Screen orientation lock not supported');
      }
    }
  }

  private setupCamera() {
    this.camera = this.cameras.main;
    this.camera.setBounds(0, 0, this.WORLD_SIZE, this.WORLD_SIZE);
    this.camera.setZoom(1);
  }

  private setupUI() {
    // UI kaldırıldı - GameComponent.tsx'deki UI kullanılacak
    // Bu sayede duplicate UI sorunu çözüldü
  }

  update(_time: number, delta: number) {
    if (!this.player.isAlive) return;

    this.updatePlayer();
    // 🎯 OPTIMIZED: Interpolate other players for smooth movement
    this.interpolateOtherPlayers(delta);
    // CLIENT-SIDE ONLY: Rendering and UI
    this.updateCamera();
    this.checkBoundaries();
    this.updateInvulnerability(); // Client-side invulnerability display
    this.render();
    // REMOVED: checkFoodCollisions() - now on server
    // REMOVED: updateGameTimer() - now on server
    // Bot death effect kaldırıldı
  }


  private updatePlayer() {
    // Calculate speed (boost or normal)
    const speed = this.isBoostActive ? this.BOOST_SPEED : this.PLAYER_SPEED;

    // Debug: Boost durumunu kontrol et (performans için azaltıldı)
    if (this.isBoostActive && Math.random() < 0.1) { // Sadece %10 şansla log
      console.log('⚡ Boost aktif - Hız:', speed, 'Segments:', this.player.segments.length, 'Uzama efekti aktif!');
    }
    
    // SENİN İSTEĞİN: Boost efekti - Segment kaybetme (KALDIRILDI)
    // Boost sırasında segment kaybetme kaldırıldı - segmentler kalıcı olsun
    // if (this.isBoostActive && this.player.segments.length > this.MIN_SEGMENTS) {
    //   if (Math.random() < 0.05) {
    //     this.player.segments.pop();
    //     console.log('⚡ Boost: Segment lost! Remaining:', this.player.segments.length);
    //   }
    // }

    // Move player head
    this.player.x += Math.cos(this.player.angle) * speed;
    this.player.y += Math.sin(this.player.angle) * speed;

    // Update segments (follow the head) - SENİN İSTEĞİN: Boost ile uzama efekti
    if (this.player.segments.length > 0) {
      // SENİN İSTEĞİN: Segment pozisyonlarını güncelle
      // İlk segmenti (kafa) güncelle
      this.player.segments[0].x = this.player.x;
      this.player.segments[0].y = this.player.y;
      
      // SENİN İSTEĞİN: Boost ile segment aralığını artır
      const baseDistance = this.SEGMENT_SIZE;
      const boostMultiplier = this.isBoostActive ? 1.8 : 1.0; // Boost sırasında %80 daha uzak
      const targetDistance = baseDistance * boostMultiplier;

      // Smooth segment following - Boost efekti ile
      for (let i = 1; i < this.player.segments.length; i++) {
        const prev = this.player.segments[i - 1];
        const curr = this.player.segments[i];

        // SENİN İSTEĞİN: Boost ile uzama efekti
        const dx = prev.x - curr.x;
        const dy = prev.y - curr.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > targetDistance) {
          const ratio = targetDistance / distance;
          curr.x = prev.x - dx * ratio;
          curr.y = prev.y - dy * ratio;
        }
      }
    }

    // SENİN KURALLARIN: Multiplayer sync
    this.syncPlayerToServer();
  }

  // 🎯 OPTIMIZED: Reduced frequency and payload
  private syncPlayerToServer() {
    if (multiplayerService.isConnected() && this.player.isAlive) {
      // 🎯 OPTIMIZED: ~80ms (~12.5 Hz) for smoother opponent motion near encounters
      if (!this.lastSyncTime || Date.now() - this.lastSyncTime > 80) {
        multiplayerService.updatePlayer({
          x: Math.round(this.player.x),
          y: Math.round(this.player.y),
          angle: this.player.angle,
          // 🎯 OPTIMIZED: Always send segmentCount, segments only when needed
          segmentCount: this.player.segments.length,
          ...(this.shouldSendSegments() && {
          segments: this.player.segments.map(seg => ({
            x: Math.round(seg.x),
            y: Math.round(seg.y)
            }))
          }),
          kills: this.player.kills,
          isAlive: this.player.isAlive,
          color: this.player.color
        });
        this.lastSyncTime = Date.now();
      }
    }
  }

  // 🎯 OPTIMIZED: Only send segments on growth or every 500ms
  private shouldSendSegments(): boolean {
    const now = Date.now();
    if (!this.lastSegmentsSent || now - this.lastSegmentsSent > 500) {
      this.lastSegmentsSent = now;
      return true;
    }
    return false;
  }

  private lastSyncTime: number = 0;
  private lastSegmentsSent: number = 0;

  private updateCamera() {
    // Follow player with smooth camera
    this.camera.centerOn(this.player.x, this.player.y);
    
    // DİNAMİK ZOOM SİSTEMİ - Segment sayısına göre zoom değişir
    const segmentCount = this.player.segments.length;
    let minZoom, maxZoom;
    
    if (segmentCount <= 10) {
      // Küçük Yılan (0-10 segment): Daha yakın görüş
      minZoom = 1.0;
      maxZoom = 1.2;
    } else if (segmentCount <= 20) {
      // Orta Yılan (11-20 segment): Orta görüş 
      minZoom = 0.8;
      maxZoom = 1.0;
    } else {
      // Büyük Yılan (20+ segment): En geniş görüş
      minZoom = 0.6;
      maxZoom = 0.8;
    }
    
    // Her kategori içinde smooth geçiş
    let categoryProgress;
    if (segmentCount <= 10) {
      categoryProgress = segmentCount / 10; // 0-10 arası normalize et
    } else if (segmentCount <= 20) {
      categoryProgress = (segmentCount - 10) / 10; // 11-20 arası normalize et  
    } else {
      categoryProgress = Math.min((segmentCount - 20) / 30, 1); // 20+ normalize et (max 50'ye kadar)
    }
    
    // Smooth zoom geçişi - büyüdükçe zoom out
    const targetZoom = maxZoom - (categoryProgress * (maxZoom - minZoom));
    
    // Debug: Zoom değişimini logla (performans için sadece değiştiğinde)
    if (this.lastZoom !== targetZoom) {
      console.log(`🔍 Zoom Update: Segments=${segmentCount}, Category=${segmentCount <= 10 ? 'Small' : segmentCount <= 20 ? 'Medium' : 'Large'}, Zoom=${targetZoom.toFixed(2)}`);
      this.lastZoom = targetZoom;
    }
    
    this.camera.setZoom(targetZoom);
  }
  
  private lastZoom: number = 0; // Debug için

  // REMOVED: checkFoodCollisions() - Food collision is now handled on server
  // Server broadcasts food changes and player growth via GAME_STATE_UPDATE

  // SENİN İSTEĞİN: Daha güzel yem renkleri (kullanılmıyor)
  // private getRandomFoodColor(): number {
  //   const foodColors = [
  //     0x00ffcc, 0xff6b6b, 0x4ecdc4, 0x45b7d1, 0x96ceb4,
  //     0xfeca57, 0xff9ff3, 0x54a0ff, 0x5f27cd, 0x00d2d3,
  //     0xff9f43, 0x10ac84, 0xee5a24, 0x0abde3, 0xc44569
  //   ];
  //   return Phaser.Utils.Array.GetRandom(foodColors);
  // }

  // SERVER AUTHORITY: Collision detection server'da yapılıyor
  // Client sadece server'dan gelen death event'ini işler


  // SENİN KURALLARIN: Ölüm efekti (kullanılmıyor)
  // private createDeathEffect() {
  //   this.player.segments.forEach((segment) => {
  //     for (let i = 0; i < 3; i++) {
  //       this.food.push({
  //         x: segment.x + Phaser.Math.Between(-20, 20),
  //         y: segment.y + Phaser.Math.Between(-20, 20),
  //         color: this.player.color,
  //         size: Phaser.Math.Between(4, 8)
  //       });
  //     }
  //   });
  //   console.log('💥 Death effect created');
  // }


  private checkBoundaries() {
    // Karakterin oyun alanı dışına çıkmasını engelle
    const margin = 100; // ✅ Kenarlardan 100 pixel mesafe bırak - Daha güvenli alan

    // X ekseni sınırları
    if (this.player.x < margin) {
      this.player.x = margin;
    }
    if (this.player.x > this.WORLD_SIZE - margin) {
      this.player.x = this.WORLD_SIZE - margin;
    }
    
    // Y ekseni sınırları
    if (this.player.y < margin) {
      this.player.y = margin;
    }
    if (this.player.y > this.WORLD_SIZE - margin) {
      this.player.y = this.WORLD_SIZE - margin;
    }
  }

  private render() {
    // Clear player graphics only; keep food until it changes (perf)
    this.playerGraphics.clear();

    // Render player
    this.renderPlayer(this.player);

    // Render other players
    this.otherPlayers.forEach(player => {
      if (player.segments && player.segments.length > 0) {
        player.segments[0].x = player.x;
        player.segments[0].y = player.y;
      }
      this.renderPlayer(player);
    });
  }

  private renderPlayer(player: PlayerData) {
    if (!player.isAlive) return;

    // SENİN İSTEĞİN: Slither.io tarzı profesyonel görsel
    const isInvulnerable = player.isInvulnerable || false;
    const isBoosted = this.isBoostActive && player.id === this.player.id; // Boost kontrolü
    const invulnerabilityAlpha = isInvulnerable ? 0.7 : 0.95; // Daha opak
    
    // SENİN İSTEĞİN: Boost sırasında kendi renginde kal
    const playerColor = player.color; // Her zaman kendi renginde
    const glowIntensity = isInvulnerable ? 0.6 : (isBoosted ? 0.4 : 0.2); // Boost sırasında daha parlak
    
    // Render segments (body) with Slither.io style
    for (let i = player.segments.length - 1; i >= 0; i--) {
      const segment = player.segments[i];
      const size = i === 0 ? this.SEGMENT_SIZE + 2 : this.SEGMENT_SIZE; // Slither.io tarzı kafa
      
      // SENİN İSTEĞİN: Slither.io tarzı glow (daha subtle)
      this.playerGraphics.fillStyle(0xffffff, glowIntensity * 0.2);
      this.playerGraphics.fillCircle(segment.x, segment.y, size + 2);

      // SENİN İSTEĞİN: Slither.io tarzı gradient body
      this.playerGraphics.fillStyle(playerColor, invulnerabilityAlpha);
      this.playerGraphics.fillCircle(segment.x, segment.y, size);

      // SENİN İSTEĞİN: Slither.io tarzı outline
      if (isInvulnerable) {
        // Invulnerable oyuncular için Slither.io tarzı glow
        this.playerGraphics.lineStyle(3, 0x00ffcc, 0.8);
        this.playerGraphics.strokeCircle(segment.x, segment.y, size + 2);
        
        // Subtle extra glow
        this.playerGraphics.lineStyle(1, 0xffffff, 0.4);
        this.playerGraphics.strokeCircle(segment.x, segment.y, size + 4);
      } else if (isBoosted) {
        // Boost sırasında daha belirgin outline
        this.playerGraphics.lineStyle(3, playerColor, 0.8); // Kendi rengiyle kalın outline
        this.playerGraphics.strokeCircle(segment.x, segment.y, size + 2);
        
        // Boost glow efekti
        this.playerGraphics.lineStyle(2, playerColor, 0.6); // Kendi rengiyle glow
        this.playerGraphics.strokeCircle(segment.x, segment.y, size + 4);
      } else {
        // Slither.io tarzı normal outline
        this.playerGraphics.lineStyle(2, 0x000000, 0.6);
      this.playerGraphics.strokeCircle(segment.x, segment.y, size);
        
        // Slither.io tarzı highlight
        this.playerGraphics.lineStyle(1, 0xffffff, 0.3);
        this.playerGraphics.strokeCircle(segment.x, segment.y, size - 1);
      }
    }

    // Render head with eyes
    if (player.segments.length > 0) {
      const head = player.segments[0];

      // Head
      this.playerGraphics.fillStyle(player.color);
      this.playerGraphics.fillCircle(head.x, head.y, this.SEGMENT_SIZE + 2);

      // Eyes
      const eyeOffset = 6;
      const eyeAngle1 = player.angle - 0.5;
      const eyeAngle2 = player.angle + 0.5;

      this.playerGraphics.fillStyle(0xffffff);
      this.playerGraphics.fillCircle(
        head.x + Math.cos(eyeAngle1) * eyeOffset,
        head.y + Math.sin(eyeAngle1) * eyeOffset,
        2
      );
      this.playerGraphics.fillCircle(
        head.x + Math.cos(eyeAngle2) * eyeOffset,
        head.y + Math.sin(eyeAngle2) * eyeOffset,
        2
      );

      // Pupils
      this.playerGraphics.fillStyle(0x000000);
      this.playerGraphics.fillCircle(
        head.x + Math.cos(eyeAngle1) * eyeOffset,
        head.y + Math.sin(eyeAngle1) * eyeOffset,
        1
      );
      this.playerGraphics.fillCircle(
        head.x + Math.cos(eyeAngle2) * eyeOffset,
        head.y + Math.sin(eyeAngle2) * eyeOffset,
        1
      );
    }
  }

  // private getMaxSegments(): number {
  //   return 50;
  // }

  // REMOVED: updateGameTimer() - Timer is now managed by server
  // Server broadcasts timer updates via TIMER_UPDATE events

  // SENİN İSTEĞİN: Invulnerability kontrolü
  private updateInvulnerability() {
    const currentTime = Date.now();
    const spawnElapsed = currentTime - this.player.spawnTime;
    const invulnerabilityDuration = 10000; // 10 saniye (milliseconds)
    
    // 10 saniye geçti mi kontrol et
    if (spawnElapsed >= invulnerabilityDuration && this.player.isInvulnerable) {
      this.player.isInvulnerable = false;
      console.log('🛡️ Invulnerability ended - Player can now be killed');
    }
    
    // Debug: Invulnerability durumunu göster
    if (this.player.isInvulnerable) {
      const remainingTime = Math.ceil((invulnerabilityDuration - spawnElapsed) / 1000);
      console.log(`🛡️ Invulnerable for ${remainingTime} more seconds`);
    }
  }


  // SERVER AUTHORITY: Oyun bitme server'dan geliyor
  private endGame() {
    this.player.isAlive = false;
    const elapsedTime = this.serverGameStartTime ? Date.now() - this.serverGameStartTime : 0;

    console.log('🏁 Game ended - Time:', elapsedTime);

    // Emit death event (will be used for blockchain integration)
    this.events.emit('playerDied', {
      kills: this.player.kills, // Server'dan gelen son değer
      survivalTime: elapsedTime
    });
  }

  // Public methods for external access - SENİN KURALLARIN
  public getPlayerKills(): number {
    return this.player.kills; // Server authority
  }

  public getGameTime(): number {
    return this.serverGameStartTime ? Date.now() - this.serverGameStartTime : 0;
  }

  public isPlayerAlive(): boolean {
    return this.player.isAlive;
  }

  public killPlayer() {
    this.player.isAlive = false;
    this.endGame(); // Sadece kendi ekranında game over ekranı gelsin
    
    // ✅ ÖLEN OYUNCU İÇİN BLOCKCHAIN endGame() ÇAĞIR
    if (this.currentGameId) {
      import('../services/Web3Service').then(({ web3Service }) => {
        web3Service.endGame(this.player.kills || 0);
      }).catch(error => {
        console.error('❌ Failed to call endGame for killed player:', error);
      });
    }
  }

  public resetPlayer() {
    this.initializePlayer();
    // REMOVED: generateFood() - Food is now generated by server
  }

  // 🎯 OPTIMIZED: Memory leak cleanup
  shutdown() {
    console.log('🧹 GameScene cleanup - removing event listeners');
    
    // Remove custom event listeners
    window.removeEventListener('foodCreated', this.handleFoodCreated as unknown as EventListener);
    
    // Clear arrays
    this.food = [];
    
    // 🎯 OPTIMIZED: Clear other players map on cleanup only
    this.otherPlayers.clear();
    
    // Clear graphics objects
    if (this.playerGraphics) {
      this.playerGraphics.destroy();
    }
    if (this.foodGraphics) {
      this.foodGraphics.destroy();
    }
    
    console.log('✅ GameScene cleanup complete');
  }

  private handleFoodCreated = (event: CustomEvent) => {
    const { newFood } = event.detail;
    newFood.forEach((foodItem: any) => {
      this.food.push({
        x: foodItem.x,
        y: foodItem.y,
        color: foodItem.color,
        size: foodItem.size
      });
    });
  };
}